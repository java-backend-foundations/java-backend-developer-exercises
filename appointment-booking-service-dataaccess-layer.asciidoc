:toc: macro
:sectnums:
:sectnumlevels: 3

= Appointment Booking System - Data Access Layer

In this chapter we are going to create a database schema with initial data.
Then we will map it into entities model and provide operations for management of the entities.

toc::[]

== Create your component

After you have completed your own link:appointment-booking-service-setup.asciidoc[Appointment Booking System Setup], we are going to create our first app component.

Going back to our example application, link:appointment-booking-system-specification.asciidoc[Appointment Booking System], we need to provide basic functionalities:

- Adding a new `Treatment` associated with a `Specialist`
- Retrieving a list of available `Treatments`, optionaly filtered by `Specialist` or `Treatment` name
- Retrieving the details of a `Treatment` - gathering information from `Treatment` and connected `Specialist`
- Choosing a `Treatment` as a `Client` and creating an `Appointment` for a given date and hour
- Validation of `Appointment` date conflict by checking if the date does not colide with other Appointments assigned to a `Specialist` (there can`t be two `Appointments` created for the same `Specialist` at the same time)
- Possibility for a `Client` to check their own appointments
- Cancelling the `Appointment` by the `Client`
- Marking the `Appointment` as completed by the `Specialist`
- Optional: retrieving the history of visits for a `Client` and a `Specialist`

To accomplish that we are going to work with five entities: _UserEntity_, _ClientEntity_, _SpecialistEntity_, _TreatmentEntity_ and _AppointmentEntity_.

image::images/dataaccess/dataaccess_entities_uml.png[width="1000", link="images/dataaccess/dataaccess_entities_uml.png"]

Each of the entities will have autogenerated id and version which specifies version number of the entity.

The _UserEntity_ will be defined by email, passwordHash, firstname and lastname. The email will always be unique.

The _ClientEntity_ will have a _UserEntity_, which it's connected to. It will also have a collection of appointments (_AppointmentEntities_).

The _SpecialistEntity_ will be defined by a specialization (as an enum of type _Specialization_, with a converter). It will have a _UserEntity_, which it's connected to and hold a list of treatments, a certain specialist provides (_TreatmentEntities_).

The _TreatmentEntity_ will be defined by name, description and duration of the treatment (in minutes). It will have a SpecialistEntity, which describes, which specialist provides given treatment.

The _AppointmentEntity_ will be defined by dateTime and status (as an enum of type _AppointmentStatus_). It will have a _ClientEntity_ and _TreatmentEntity_, with which it's connected.

* *One-to-One Relationships*
** A *User* has a *one-to-one* relationship with *Client*.
** A *User* has a *one-to-one* relationship with *Specialist*. +
Each user can either be a *Client* or a *Specialist*, but not both.

* *One-to-Many Relationships*
** A *Specialist* has a *one-to-many* relationship with *Treatment*. +
A specialist can provide multiple treatments, but each treatment is provided by only one specialist.
** A *Client* has a *one-to-many* relationship with *Appointment*. +
A client can book multiple appointments, but each appointment belongs to only one client.
** A *Treatment* has a *one-to-many* relationship with *Appointment*. +
A treatment can be booked in multiple appointments, but each appointment refers to only one treatment.

* *Many-to-One Relationships*
** An *Appointment* has a *many-to-one* relationship with *Client*. +
Multiple appointments can belong to the same client.
** An *Appointment* has a *many-to-one* relationship with *Treatment*. +
Multiple appointments can be scheduled for the same treatment.
    
Only relationships Client - Appointment, and Specialist - Treatment are bidirectional.

=== The database

For the sake of the training we will be working with H2 database engine to create our database schema.
We will be using flyway to migrate our database scheme.

You can check that your schema is valid running AppointmentBookingAppApplication.java which recreates schema after each run. Created schema can be found in the H2 console.

image::images/dataaccess/dataaccess_database_uml.png[width="500", link="images/dataaccess/dataaccess_database_uml.png"]

Lets start with the database schema. Create a new sql file _V0001__Create_schema.sql_ in appointment-booking-app/src/main/resources/db/migration/1.0/ folder.

==== _USER_TABLE_ table

We will add our first table USER_TABLE in /appointment-booking-app/src/main/resources/db/migration/1.0/V0001__Create_schema.sql. In the case of AppointmentBookingService, the Users will provide: id, version, email etc. Additionally, emails need to be unique among all users. So we need to represent that data in our table:

[source,sql]
----
CREATE TABLE USER_TABLE (
ID NUMBER(19,0) NOT NULL AUTO_INCREMENT,
VERSION INTEGER NOT NULL,
EMAIL VARCHAR(128),
PASSWORD_HASH VARCHAR(128),
FIRST_NAME VARCHAR(128),
LAST_NAME VARCHAR(128),
PRIMARY KEY (ID),
CONSTRAINT UNIQUE_USER_EMAIL UNIQUE (EMAIL)
);
----
 
- ID: the id for each item, automatically incremented using sequence HIBERNATE_SEQUENCE.
- VERSION: used internally by JPA to take care of the optimistic locking for us.
- EMAIL: Email address of the user. Unique.
- PASSWORD_HASH: a secure way to store passwords in the database (further described in the Security Part of the exercises).
- FIRST_NAME: User's first name
- LAST_NAME: User's last name
 
We will also set the constraints:

- primary key for id to take care of it's uniqueness.
- UNIQUE_USER_EMAIL unique constraing for email column.

Notice, how we are using *USER_TABLE* instead of just *USER* as a name. USER is a reserved word, and we can't create a table with that name.

==== _CLIENT_ table

We will now add the CLIENT table in `/appointment-booking-app/src/main/resources/db/migration/1.0/V0001__Create_schema.sql`.  
Each Client is associated with a User, meaning there is a **one-to-one relationship** between the CLIENT and USER_TABLE. We add the *ON DELETE CASCADE* clause, because Client can't exist without a User - and if the User is deleted, the Client should be removed as well.  

[source,sql]
----
CREATE TABLE CLIENT (
ID NUMBER(19,0) NOT NULL AUTO_INCREMENT,
VERSION INTEGER NOT NULL,
USER_ID NUMBER(19,0) NOT NULL,
PRIMARY KEY (ID),
FOREIGN KEY (USER_ID) REFERENCES USER_TABLE(ID) ON DELETE CASCADE
);
----

- ID: the unique identifier for each client, automatically incremented.
- VERSION: used internally by JPA to handle optimistic locking.
- USER_ID: a reference to the associated user in the USER_TABLE.

We will also set the constraints:

- primary key for ID to ensure uniqueness.
- foreign key constraint linking USER_ID to the USER_TABLE.

Since a User can either be a Client or a Specialist (but not both), this table ensures proper role separation in the system.

==== _SPECIALIST_ table

Now lets add the SPECIALIST table.
Each Specialist is associated with a User, meaning there is a **one-to-one relationship** between the SPECIALIST and USER_TABLE.  
Additionally, a Specialist has a specialization field to describe their expertise.

The table should contain following columns:

- ID: the unique identifier for each specialist, automatically incremented.
- VERSION: used internally by JPA for optimistic locking.
- SPECIALIZATION: the field of expertise for the specialist (e.g. "Dentist", "Orthopaedist").
- USER_ID: a reference to the associated user in the USER_TABLE.

We will also set the constraints:

- primary key for ID to ensure uniqueness.
- foreign key constraint linking USER_ID to the USER_TABLE. Remember about *ON DELETE CASCADE* clause.

==== _TREATMENT_ table

Now lets add the TREATMENT table.
Each Treatment is provided by a Specialist, meaning there is a **many-to-one relationship** between the TREATMENT and SPECIALIST.

[source,sql]
----
CREATE TABLE TREATMENT (
(...)
SPECIALIST_ID NUMBER(19,0),
(...)
FOREIGN KEY (SPECIALIST_ID) REFERENCES SPECIALIST(ID) ON DELETE CASCADE
);
----

In this case, we also assume, that a treatment should be removed, if the specialist is removed.

The table should contain following columns:

- ID: the unique identifier for each treatment, automatically incremented.
- VERSION: used internally by JPA for optimistic locking.
- NAME: the name of the treatment (e.g., "Relaxing Massage").
- DESCRIPTION: a detailed description of the treatment.
- DURATION_MINUTES: the estimated duration of the treatment in minutes.
- SPECIALIST_ID: a reference to the Specialist providing the treatment.

We will also set the constraints:

- primary key for ID to ensure uniqueness.
- foreign key constraint linking SPECIALIST_ID to the SPECIALIST table.

==== _APPOINTMENT_ table

Finishing off, lets add the APPOINTMENT table.
Each Appointment is booked by a Client and is associated with a specific Treatment.  
This means there are **many-to-one relationships** between APPOINTMENT and both CLIENT and TREATMENT, which means two foreign keys for the APPOINTMENT table.

The table should contain following columns:

* ID: the unique identifier for each appointment, automatically incremented.
* VERSION: used internally by JPA for optimistic locking.
* DATE_TIME: the scheduled date and time for the appointment.
* STATUS: the current status of the appointment (default value: `SCHEDULED`), which can be:
** `SCHEDULED`: Appointment is booked but not yet completed.
** `CANCELLED`: Appointment has been canceled.
** `COMPLETED`: Appointment has been completed successfully. 
* CLIENT_ID: a reference to the Client who booked the appointment.
* TREATMENT_ID: a reference to the Treatment associated with the appointment.

We will also set the constraints:

- primary key for ID to ensure uniqueness.
- foreign key constraint linking CLIENT_ID to the CLIENT table - with *ON DELETE CASCADE* clause
- foreign key constraint linking TREATMENT_ID to the TREATMENT table - with *ON DELETE CASCADE* clause

A Client can book multiple Appointments, and a Treatment can have multiple Appointments, but each Appointment is linked to a single Client and a single Treatment.

==== Mockdata
Finally we can provide a certain amount of mock data to start our app. Add a new sql script /appointment-booking-app/src/main/resources/db/migration/1.0/V0002__Create_mockdata.sql adding sample data:

[%nowrap,sql]
----
-- USERS - Clients
INSERT INTO USER_TABLE(ID, VERSION, FIRST_NAME, LAST_NAME, PASSWORD_HASH, EMAIL) VALUES (-1, 0, 'Stefan', 'Kowalski', 'passwordHash1', 'stefan.kowalski@gmail.com');
INSERT INTO USER_TABLE(ID, VERSION, FIRST_NAME, LAST_NAME, PASSWORD_HASH, EMAIL) VALUES (-2, 0, 'Anna', 'Nowak', 'passwordHash2', 'annan@yahoo.com');
INSERT INTO USER_TABLE(ID, VERSION, FIRST_NAME, LAST_NAME, PASSWORD_HASH, EMAIL) VALUES (-3, 0, 'Luiza', 'Poniatowska', 'passwordHash3', 'poniatowskaluiza@o2.pl');
INSERT INTO USER_TABLE(ID, VERSION, FIRST_NAME, LAST_NAME, PASSWORD_HASH, EMAIL) VALUES (-4, 0, 'Grzegorz', 'Maniewicz', 'passwordHash4', 'g.maniewicz@gmail.com');

-- USERS - Specialists
INSERT INTO USER_TABLE(ID, VERSION, FIRST_NAME, LAST_NAME, PASSWORD_HASH, EMAIL) VALUES (-5, 0, 'Dobromir', 'Zegula', 'passwordHash5', 'zegula.d@gmail.com');
INSERT INTO USER_TABLE(ID, VERSION, FIRST_NAME, LAST_NAME, PASSWORD_HASH, EMAIL) VALUES (-6, 0, 'Monika', 'Siewiczowa', 'passwordHash6', 'monika.s@yahoo.com');
INSERT INTO USER_TABLE(ID, VERSION, FIRST_NAME, LAST_NAME, PASSWORD_HASH, EMAIL) VALUES (-7, 0, 'Andrzej', 'Piaseczny', 'passwordHash7', 'a.j.piaseczny@o2.pl');
INSERT INTO USER_TABLE(ID, VERSION, FIRST_NAME, LAST_NAME, PASSWORD_HASH, EMAIL) VALUES (-8, 0, 'Patrycja', 'Milewska', 'passwordHash8', 'milewskap@gmail.com');

-- CLIENTS
INSERT INTO CLIENT(ID, VERSION, USER_ID) VALUES (-1, 0, -1);
INSERT INTO CLIENT(ID, VERSION, USER_ID) VALUES (-2, 0, -2);
INSERT INTO CLIENT(ID, VERSION, USER_ID) VALUES (-3, 0, -3);
INSERT INTO CLIENT(ID, VERSION, USER_ID) VALUES (-4, 0, -4);

-- SPECIALISTS
INSERT INTO SPECIALIST(ID, VERSION, USER_ID, SPECIALIZATION) VALUES (-1, 0, -5, 'Dentist');
INSERT INTO SPECIALIST(ID, VERSION, USER_ID, SPECIALIZATION) VALUES (-2, 0, -6, 'Cardiologist');
INSERT INTO SPECIALIST(ID, VERSION, USER_ID, SPECIALIZATION) VALUES (-3, 0, -7, 'Pediatrician');
INSERT INTO SPECIALIST(ID, VERSION, USER_ID, SPECIALIZATION) VALUES (-4, 0, -8, 'Orthopaedist');

-- TREATMENTS
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-1, 0, 'Konsultacja dentystyczna', 'Konsultacja dentystyczna z diagnostyką i planem leczenia', 30, -1);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-2, 0, 'Leczenie kanałowe', 'Leczenie kanałowe pojedynczego zęba ze znieczuleniem', 120, -1);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-3, 0, 'Konsultacja kardiologiczna', 'Konsultacja kardiologiczna z wstępną diagnostyką', 30, -2);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-4, 0, 'USG serca', 'USG serca z diagnostyką', 45, -2);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-5, 0, 'Konsultacja pediatryczna', 'Konsultacja pediatryczna w przypadku choroby', 20, -3);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-6, 0, 'Bilans 2-latka', 'Bilans dwulatka z przygotowaniem dokumentacji', 40, -3);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-7, 0, 'Wymaz z nosogardła', 'Wymaz pobierany z części nosowej gardła w celu diagnostycznym', 10, -3);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-8, 0, 'Bilans 5-latka', 'Bilans pięciolatka z przygotowaniem dokumentacji', 40, -3);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-9, 0, 'Płukanie żołądka', 'Interwencyjne płukanie żołądka', 30, -3);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-10, 0, 'Konsultacja ortopedyczna', 'Konsultacja ortopedyczna z diagnostyką', 30, -4);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-11, 0, 'Usunięcie haluksów', 'Operacja usunięcia haluksów z korekcję torebki stawowej i ścięgien', 75, -4);
INSERT INTO TREATMENT(ID, VERSION, NAME, DESCRIPTION, DURATION_MINUTES, SPECIALIST_ID) VALUES (-12, 0, 'Rekonstrukcja więzadła ACL', 'Rekonstrukcją więzadła krzyżowego przedniego (ACL) z zastąpieniem uszkodzonego więzadła nowym więzadłem ze ścięgien pacjenta.', 180, -4);
----

You can provide your own data or use the script above.

Run application and check that the data you provided is inserted into the database.

=== Entities
==== Lombok Setup 
If you don't have the lombok dependency yet, add it to the pom.xml:
[source, xml]
----
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<optional>true</optional>
</dependency>
----

You might have to install lombok separately in your IDE for the lombok annotations to work.

==== Creating the package structure

TODO WITH SCREENSHOTS, after code review

==== UserEntity

Create a new class _UserEntity_.

Mark the class with `@Entity` and `@Table` annotations, specifying the table name.  
Additionally, mark the class with @Getters and @Setters annotations from lombok - this will allow a getter and setter generation "in the background", without adding them in the class.

Define private attributes based on the schema (_id, version, email, passwordHash, firstname, lastname_).  
Mark the _id_ attribute with `@Id` and `@GeneratedValue(strategy = GenerationType.IDENTITY)`, which defines the generation strategy.  
Mark the _version_ attribute with `@Version` to handle optimistic locking automatically.  

To ensure correct mapping to the database, add the `@Column` annotation with a specified name where needed (where the name in the database is not 1:1 with the name in java).

[source,java]
----
@Entity
@Table(name = "USER_TABLE")
@Getter
@Setter
public class UserEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Version
    private Integer version;

    @Column(name = "PASSWORD_HASH")
    private String passwordHash;
    
(...)
}

----

==== ClientEntity

Next to the UserEntity create ClientEntity. Mark the class with proper annotations. Prepare attributes as shown in the schema. For Id and Version use the same annotations, as in UserEntity.
 
Now, lets implement the **uni-directional @OneToOne relationship** between the person and the task list. 
ClientEntity will be the owner of the relationship. Add a private attribute of type UserEntity in ClientEntity. Mark it with @OneToOne annotation and specify, that the relationship is not optional. Specify the cascade operations. 
Additionally, you can add a @JoinColumn annotation, which will precisely describe what is the name of the Foreign Key column in the database in the CLIENT table, and which column it references in USER_TABLE table.

[source,java]
----
    @OneToOne(optional = false, cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE })
    @JoinColumn(name = "USER_ID", referencedColumnName = "ID")
    private UserEntity user;
----

We will add the **bi-directional @ManyToOne relationship** to AppointmentEntity later on.

==== SpecialistEntity

Next to the previous entities create _SpecialistEntity_. Mark the class with proper annotations.  
Prepare attributes as shown in the schema. For _id_ and _version_, use the same annotations as in _UserEntity_.

For specialization attribute, *create an Enum* _Specialization_ in _/common/datatype_ package:

[source,java]
----
public enum Specialization {
	
	DENTIST("Dentist"), 
	CARDIOLOGIST("Cardiologist"), 
	PEDIATRICIAN("Pediatrician"), 
	UROLOGIST("Urologist"), 
	NEUROLOGIST("Neurologist"), 
	ORTHOPAEDIST("Orthopaedist");
	
	private String name;

	private Specialization(String name) {
		this.name = name;
	}

	public String getName() {
		return this.name;
	}
	
	public static Specialization getByName(String name) {

		for (Specialization s : Specialization.values()) {
			if (s.getName().equals(name)) {
				return s;
			}
		}
		return null;
	}
	
}
----

The _getByName_ method will be needed for our converter. 

But before that, let’s implement the **uni-directional @OneToOne relationship** between _SpecialistEntity_ and _UserEntity_.  
_SpecialistEntity_ will be the owner of the relationship.  
Add a private attribute of type _UserEntity_ in _SpecialistEntity_. Mark it with `@OneToOne` annotation.  
Additionally, you can use `@JoinColumn` to specify the foreign key column in the _SPECIALIST_ table and its reference in _USER_TABLE_.

To ensure correct mapping to the database, add the `@Column` annotation with a specified name where needed.

We will add the **bi-directional @OneToMany relationship** to _TreatmentEntity_ later on.

===== Converting the specialization attribute

Now, let’s implement an **Attribute Converter** for the `Specialization` enum.  

In JPA, an `@Converter` allows us to customize how an enum is stored in the database.  
By default, JPA can store enums as **ordinal values** (integers) or **names** (string representations of enum constants).  
However, in our case, we want to store the **custom name field** of the `Specialization` enum instead of its default `name()`.  

To achieve this, we will:  
- Create a new class `SpecializationConverter` in package _/common/converter_ 
- Implement `AttributeConverter<Specialization, String>`  
- Override the `convertToDatabaseColumn(Specialization specialization)` method to return `specialization.getName()`  
- Override the `convertToEntityAttribute(String dbData)` method to use `Specialization.getByName(dbData)`  
- Mark the class with `@Converter`

====== a. Implementation

[source,java]
----
import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

@Converter
public class SpecializationConverter implements AttributeConverter<Specialization, String> {

    @Override
	public String convertToDatabaseColumn(Specialization specialization) {
		
		return specialization != null ? specialization.getName() : null;
		
	}

    @Override
    public Specialization convertToEntityAttribute(String dbData) {
        if (dbData == null) {
            return null;
        }
        return Specialization.getByName(dbData);
    }
}
----

====== b. Usage in SpecialistEntity

To ensure the conversion is applied, annotate the `specialization` field in _SpecialistEntity_ with `@Convert(converter = SpecializationConverter.class)`.  

[source,java]
----
@Convert(converter = SpecializationConverter.class)
private Specialization specialization;
----

We could also mark the Converter as `@Converter(autoApply = true)`, so that JPA automatically applies it to all entity fields of type `Specialization`.
If we do so, we **don’t need to explicitly annotate each occurrence of Specialization**, as JPA will apply the converter automatically.  

Important to note - annotation @Enumerated and @Convert can not coexist! You have to either use one or another.

==== TreatmentEntity

Next to other entities create _TreatmentEntity_. Mark the class with proper annotations.  
Prepare attributes as shown in the schema. Use the same annotations for _id_ and _version_ as in _UserEntity_.

Now, let’s implement the **bi-directional @ManyToOne relationship** between _TreatmentEntity_ and _SpecialistEntity_.  
_TreatmentEntity_ will be the owning side and will hold information about the specialist providing the treatment.  
Add a private attribute of type _SpecialistEntity_ in _TreatmentEntity_. Mark it with `@ManyToOne`.  
Additionally, you can use `@JoinColumn` to specify the foreign key column (but it's not necessary).

[source,java]
----
    @ManyToOne
    @JoinColumn(name = "SPECIALIST_ID", referencedColumnName = "ID")
    private SpecialistEntity specialist;
}
----

Even though _TreatmentEntity_ is the owner, we also want _SpecialistEntity_ to hold information about the treatments provided by a specialist.  

Edit _SpecialistEntity_ and add an additional private attribute of type `List<TreatmentEntity>`.  
Mark the attribute with `@OneToMany`, defining which attribute this relationship is mapped by, and the cascade types.

[source,java]
----
@OneToMany(mappedBy = "specialist", cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE })
private List<TreatmentEntity> treatments;
----

==== AppointmentEntity

Next to the previous entities create _AppointmentEntity_. Mark the class with proper annotations.  
Prepare attributes as shown in the schema. Use the same annotations for _id_ and _version_ as in _UserEntity_.

For _status_ attribute, create a simple enum AppointmentStatus next to the _Specialization_ enum:

[source,java]
----
public enum AppointmentStatus {
SCHEDULED, CANCELLED, COMPLETED;
}
----

Don't forget the @Enumerated annotation here, with EnumType.STRING.

Now, let’s implement **bi-directional @ManyToOne relationship** between _AppointmentEntity_ and _ClientEntity_.  
_AppointmentEntity_ is the owning side and will store a reference to the client booking the appointment.

Add a private attribute of type _ClientEntity_ in _AppointmentEntity_.  
Mark it with `@ManyToOne` annotation and specify the foreign key column with `@JoinColumn`.

Even though _AppointmentEntity_ is the owner, we also want _ClientEntity_ to hold a reference to the appointments booked by a client.  

Edit _ClientEntity_ and add a private attribute of type `List<AppointmentEntity>`.  
Mark it with `@OneToMany`, specifying the mapped attribute and cascade types. Add orphanRemoval=true, so that the Appointment will be removed, then the connection between Client and Appointment is broken.

[source,java]
----
@OneToMany(mappedBy = "client", cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE }, orphanRemoval=true)
private List<AppointmentEntity> appointments;
----

Additionally, let’s implement the **uni-directional @ManyToOne relationship** between AppointmentEntity and TreatmentEntity.
AppointmentEntity will store a reference to the treatment that the appointment is associated with, but TreatmentEntity will not store any reference to AppointmentEntity.
This means we only define the relationship in AppointmentEntity, making it a one-way connection.

Add a private attribute of type TreatmentEntity in AppointmentEntity.
Mark it with @ManyToOne annotation.

You are ready to go!

TODO Repositories
