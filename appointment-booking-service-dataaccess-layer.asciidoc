:toc: macro
:sectnums:
:sectnumlevels: 3

= Appointment Booking Service - Data Access Layer

In this chapter we are going to create a database schema with initial data.
Then we will map it into entities model and provide operations for management of the entities.

toc::[]

== Create your component

After you have completed your own link:appointment-booking-service-setup.asciidoc[Appointment Booking Service Setup], we are going to create our first app component.

Going back to our example application, link:appointment-booking-service.asciidoc[Appointment Booking Service], we need to provide basic functionalities:

- Adding a new `Treatment` associated with a `Specialist`
- Retrieving a list of available `Treatments`, optionaly filtered by `Specialist` or `Treatment` name
- Retrieving the details of a `Treatment` - gathering information from `Treatment` and connected `Specialist`
- Choosing a `Treatment` as a `Client` and creating an `Appointment` for a given date and hour
- Validation of `Appointment` date conflict by checking if the date does not colide with other Appointments assigned to a `Specialist` (there can`t be two `Appointments` created for the same `Specialist` at the same time)
- Possibility for a `Client` to check their own appointments
- Cancelling the `Appointment` by the `Client`
- Marking the `Appointment` as completed by the `Specialist`
- Optional: retrieving the history of visits for a `Client` and a `Specialist`

To accomplish that we are going to work with five entities: _UserEntity_, _ClientEntity_, _SpecialistEntity_, _TreatmentEntity_ and _AppointmentEntity_.

image::images/dataaccess/dataaccess_entities_uml.png[width="1000", link="images/dataaccess/dataaccess_entities_uml.png"]

Each of the entities will have autogenerated id and version which specifies version number of the entity.

The _UserEntity_ will be defined by email, passwordHash, firstname and lastname. The email will always be unique.

The _ClientEntity_ will have a _UserEntity_, which it's connected to. It will also have a collection of appointments (_AppointmentEntities_).

The _SpecialistEntity_ will be defined by a specialization (as an enum of type _Specialization_, with a converter). It will have a _UserEntity_, which it's connected to and hold a list of treatments, a certain specialist provides (_TreatmentEntities_).

The _TreatmentEntity_ will be defined by name, description and duration of the treatment (in minutes). It will have a SpecialistEntity, which describes, which specialist provides given treatment.

The _AppointmentEntity_ will be defined by dateTime and status (as an enum of type _AppointmentStatus_). It will have a _ClientEntity_ and _TreatmentEntity_, with which it's connected.

- *One-to-One Relationships*
  - A *User* has a *one-to-one* relationship with *Client*.
  - A *User* has a *one-to-one* relationship with *Specialist*.
    - Each user can either be a *Client* or a *Specialist*, but not both.

- *One-to-Many Relationships*
  - A *Specialist* has a *one-to-many* relationship with *Treatment*.
    - A specialist can provide multiple treatments, but each treatment is provided by only one specialist.
  - A *Client* has a *one-to-many* relationship with *Appointment*.
    - A client can book multiple appointments, but each appointment belongs to only one client.
  - A *Treatment* has a *one-to-many* relationship with *Appointment*.
    - A treatment can be booked in multiple appointments, but each appointment refers to only one treatment.

- *Many-to-One Relationships*
  - An *Appointment* has a *many-to-one* relationship with *Client*.
    - Multiple appointments can belong to the same client.
  - An *Appointment* has a *many-to-one* relationship with *Treatment*.
    - Multiple appointments can be scheduled for the same treatment.
    
Only relationships Client - Appointment, and Specialist - Treatment are bidirectional.

=== The database

For the sake of the training we will be working with H2 database engine to create our database schema.
We will be using flyway to migrate our database scheme.

You can check that your schema is valid running AppointmentBookingAppApplication.java which recreates schema after each run. Created schema can be found in the H2 console.

image::images/dataaccess/dataaccess_database_uml.png[width="900", link="images/dataaccess/dataaccess_database_uml.png"]

Lets start with the database schema. Create a new sql file _V0001__Create_schema.sql_ in appointment-booking-app/src/main/resources/db/migration/1.0/ folder.

==== _USER_TABLE_ table

We will add our first table USER_TABLE in /appointment-booking-app/src/main/resources/db/migration/1.0/V0001__Create_schema.sql. In the case of AppointmentBookingService, the Users will provide: id, version, email etc. Additionally, emails need to be unique among all users. So we need to represent that data in our table:

[source,sql]
----
CREATE TABLE USER_TABLE (
ID NUMBER(19,0) NOT NULL AUTO_INCREMENT,
VERSION INTEGER NOT NULL,
EMAIL VARCHAR(128),
PASSWORD_HASH VARCHAR(128),
FIRST_NAME VARCHAR(128),
LAST_NAME VARCHAR(128),
PRIMARY KEY (ID),
CONSTRAINT UNIQUE_USER_EMAIL UNIQUE (EMAIL)
);
----
 
- ID: the id for each item, automatically incremented using sequence HIBERNATE_SEQUENCE.
- VERSION: used internally by JPA to take care of the optimistic locking for us.
- EMAIL: Email address of the user. Unique.
- PASSWORD_HASH: a secure way to store passwords in the database (further described in the Security Part of the exercises).
- FIRST_NAME: User's first name
- LAST_NAME: User's last name
 
We will also set the constraints:

- primary key for id to take care of it's uniqueness.
- UNIQUE_USER_EMAIL unique constraing for email column.

Notice, how we are using *USER_TABLE* instead of just *USER* as a name. USER is a reserved word, and we can't create a table with that name.
// TODO